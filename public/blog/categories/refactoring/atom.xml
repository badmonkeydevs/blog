<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Refactoring | Bad Monkey Press]]></title>
  <link href="http://badmonkeys.github.io/blog/categories/refactoring/atom.xml" rel="self"/>
  <link href="http://badmonkeys.github.io/"/>
  <updated>2016-01-11T15:11:37-05:00</updated>
  <id>http://badmonkeys.github.io/</id>
  <author>
    <name><![CDATA[Michael Kelly]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Model-less Controllers in Ruby on Rails]]></title>
    <link href="http://badmonkeys.github.io/blog/2016/01/03/model-less-controllers-in-ruby-on-rails/"/>
    <updated>2016-01-03T00:00:00-05:00</updated>
    <id>http://badmonkeys.github.io/blog/2016/01/03/model-less-controllers-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p><em><a href="https://badmonkeydev.wordpress.com/category/craft">The Bad Monkey Craft</a>: This is part of a series on software engineering
craft.  The knowledge that takes us from factual tutorials and
walkthroughs to truly elegant applications.  Each article in this series
is intended to inspire thought and conversation into the different ways
we use our web frameworks and the pieces that make them up.  Read along
and join the conversation about the craft of writing web
applications!</em></p>

<!-- more -->


<p>So you&rsquo;re fresh out of a code bootcamp like <a
href="https://generalassemb.ly/">General Assembly</a> or <a
href="https://www.theironyard.com/">The Iron Yard</a>; Or maybe you
spent some hard earned hours at the ole' google, cranking out tutorials
and examples.  What you know now is that Ruby on Rails is an MVC web app
framework and you make routes that point to controllers with actions
that represent the basic CRUD (<strong>C</strong>reate,
<strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete)
for a model. All of this is true.  Except for one small assumption&hellip;In
real-world applications, it is not always so cut and dry.  You start
collecting more and more actions in your controller to marshal different
resources, preform some kind of processing, or render non-standard
views.</p>

<p>If you keep up with this long enough, you&rsquo;ll find your controllers
getting fat, your list of actions getting longer and longer while your
text editor struggles to even parse the file. <strong>Fear Not
Adventurer!</strong> There&rsquo;s a relatively simple way to design these
creeping complexities so that your project is still maintainable and
understandable&hellip;I call this approach <em>Model-less Controllers</em>.</p>

<h2>What are Model-less Controllers?</h2>


<p><em>&ldquo;Model-less Controller&rdquo;</em> is the name I&rsquo;ve given to Rails
controllers that don&rsquo;t represent a clear-cut rails model.  They instead
represent a conceptual resource that can be just about anything.  There
are a few different types including static controllers, composite
controllers, and aggregate controllers.  We&rsquo;ll see some examples of
these in just a minute, but the easiest way to envision this concept is
that they are</p>

<blockquote>
  Model-less Controllers are controllers that do not tie one-to-one with
  a resource in your system.
</blockquote>




<h3>Not Your Average Controllers</h3>


<p>&ldquo;But, Michael, if there&rsquo;s a view or a data object behind my controller
it technically has a resource!?&rdquo; you might be asking.  Well, that&rsquo;s
true.  I&rsquo;m speaking to those in the community who are just learning
Ruby on Rails from a tutorial like <a
href="https://www.railstutorial.org/">Michael Hartle&rsquo;s</a> and are
looking to take their solution design to a higher level.  Composite or
<em>Model-less</em> controllers are those that don&rsquo;t follow the RoR
way.  They can&rsquo;t be generated as a scaffold with <code>rails
generate</code>.</p>

<p>There are a couple of different types of model-less controllers
including composite, aggregate, and static controllers.  Here are a
few examples:</p>

<h4>Static Pages a la <a href="https://www.railstutorial.org/">Michael Hartle's Rails Tutorial</a></h4>


<p>Mike uses what I call &ldquo;static&rdquo; controllers pretty early in his
tutorial when he&rsquo;s adding static pages to the example app.  These
controllers are meant primarily as a shim between the router and the
static views you want at an endpoint.  Most if any logic in these
controllers is going to be related to localization or time-based
output.</p>

<h4>Devise's Registration and Session Controllers</h4>


<p><a href="https://github.com/plataformatec/devise">Devise</a> provides
a fairly simple way to add authentication to a RoR app.  A few
commands and <strong>BOOM</strong> you&rsquo;ve got database authentication,
or OAuth integration right out of the gate&hellip;it even includes a ton of
helpful routes like <code>/users/registration/new</code> and
<code>users/session/new</code> that setup user signup and user login
to work with <a
href="https://github.com/plataformatec/devise">Devise</a>&rsquo;s internal
controllers.</p>

<p>If you&rsquo;ve ever extended any of these to customize the login behavior
or to add more detailed logic to user signup, then you&rsquo;ve worked with
<em>Composite Controllers</em>.  These controllers loosely represent a
resource in your app.  However, it is not one that ties directly to a
model.  You&rsquo;ll find no <code>Session</code> or
<code>Registration</code> models.  These are composite concepts that
relate to a type of <code>User</code> model interaction.</p>

<h4>Dashboards</h4>


<p>Modern web applications almost always require some kind of dashboard
functionality.  Whether that is an admin panel to get at-a-glance
information about your sales application, or a KPI/analytics page for
your CRM tool, it is still a page dedicated to presenting information
that intentionally cross-cuts the entire platform.  You&rsquo;ll be reading
from four tables and running aggregation mathematics to be cached and
retrieved by the page.</p>

<p>With a complicated feature like a dashboard, it is almost certain that
you&rsquo;ll find what I call <em>Aggregate Controllers</em> behind the
scenes.  These controllers are responsible for the marshaling of large
amount of data, spread seemingly at random across a massive database.
You&rsquo;ll also often see controllers like these interacting with Redis or
Memcache to access data that has been aggregated by a background
process.</p>

<h3>How Do I Implement an Aggregate/Composite Controller?</h3>


<p>So here&rsquo;s the thing.  You don&rsquo;t.  These <em>special</em> types of
controllers are nothing more than a standard Rails controller, just
without a matching model.  The difference is in how you use them and
the logic that lives within them (or the objects that they in turn
delegate action to).  My intent here is to point out that there are
many different ways to think about controllers and we can&rsquo;t let
ourselves get stuck creating entire scaffolds for features that may
have been better served by compiling or aggregating data already
available into it&rsquo;s own controller.</p>

<p>You&rsquo;ll also find that by thinking about your controllers as more than
just faceplates for your models, you can more easily refactor your
existing logic into a wider assortment of controllers, isolating logic
into conceptual units is never a bad thing ;).</p>

<h2>What about my API and RESTfulness?</h2>


<p>In talking about this topic with other engineers I&rsquo;ve found one
question pretty common.</p>

<blockquote>
  What about RESTful APIs?  Shouldn't they be resource-backed?
</blockquote>


<p>And the answer to this is &ldquo;Yes&rdquo;.  However, you&rsquo;d be surprised how
many APIs are out there that present RESTful data (data that can be
created, read, updated, and deleted) that is not in fact backed by a
specific model that matches the structure of your RESTful resource.
Think about the example I gave above about <a
href="https://github.com/plataformatec/devise">Devise</a>&rsquo;s
controller structure.  They work with a RESTful resource like a
<code>Session</code>.  A session can be created (logging in), read
(current_user specific info), updated (storing of session related
values like page visits or temporary objects), and deleted (logging
out).  It is a viable RESTful resource, but there is again no
persisted <code>Session</code> object in our application (and I&rsquo;m
not referring to the <code>session</code> hash in Rails, that is
only a key-value store that represents the so-called fields of our
conceptual <code>Session</code>.</p>

<h2>Conclusion</h2>


<p>I hope I&rsquo;ve shown you some good examples of other ways of thinking
about your Rails controllers.  Model-less controllers are a great
way to decouple the data representation used by your application and
the data representation used by your client or users.  This kind of
benefit allows your application to adapt and adjust technically
while maintaining a consistent structure in the eyes of the people
using it.</p>

<p>Do you dis/agree with me?  Leave a comment below or hit me up <a
href="https://twitter.com/thebadmonkeydev">@thebadmonkeydev</a> and
let me know what you think!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hey, Do You Even PORO?]]></title>
    <link href="http://badmonkeys.github.io/blog/2015/07/17/hey-do-you-even-poro/"/>
    <updated>2015-07-17T00:00:00-04:00</updated>
    <id>http://badmonkeys.github.io/blog/2015/07/17/hey-do-you-even-poro</id>
    <content type="html"><![CDATA[<p>Introduces POR objects and demonstrates the surprising benefits of NOT
using ActiveRecord objects</p>

<!-- more -->


<h2>First Things First</h2>

<p>I know it&rsquo;s been a couple of weeks since my last post and I owe you an
apology. I&rsquo;ve been head-down working on coming up to speed over at
<a href="http://monsieur.co/">Monsieur</a> in the <a href="http://atdc.org/">ATDC</a>. It&rsquo;s a
really cool space with excellent growth potential. I&rsquo;m taking over an
pretty well written MVP architecture and will be working hard in the
coming months to take it to true production quality. I&rsquo;ve only been at
it for just a couple of weeks now and I&rsquo;m getting really excited to see
where this product will go.  Right now we&rsquo;re also on the hunt for
another <a href="http://monsieur.co/careers/">Senior Web Engineer</a> to help me
out in this effort.  Come check us out!</p>

<p>While I&rsquo;m digging into new code, designing for growth and scale, and
forging new ground with this code base, I thought it&rsquo;d be a good idea to
share some of my thoughts on code design. Now I&rsquo;m I know what you&rsquo;re
thinking &ldquo;Michael, what happened to the next post in the <a
href="https://badmonkeydev.wordpress.com/2015/06/04/how-to-build-your-own-ruby-gem-from-start-to-finish/">How
to Build Your Own Gem series</a>? Well don&rsquo;t worry, I&rsquo;m still working on
that, I just haven&rsquo;t had much time to work on
<a href="https://github.com/michaelkelly322/sidekiq-workflow">sidekiq-workflow</a>
recently. You&rsquo;ll see more on that soon.</p>

<p>What I want to share today is a pattern I use quiet often when
refactoring and designing Rails apps. It&rsquo;s very useful for creating
writable, readable, and highly modularized code. It&rsquo;s also a great means
of introducing domain abstraction into your app which will only reveal
more patterns and abstractions that will help the app grow and expand
gracefully.</p>

<h2>POR Objects</h2>

<p>So it happens sometimes when rails apps grow that a model takes on too
much responsibility. The file is hundreds of lines long, you see methods
like <code>reset_spend_cap</code> and <code>set_spend_cap</code>, and new developers have
absolutely no idea where to find the code they need. One of the things
to remember in this situation is that just because we&rsquo;re writing a rails
app, doesn&rsquo;t mean we HAVE to use ActiveRecord for all of our objects.
Plain Old Ruby(POR) objects work <em>GREAT</em> for encapsulating modular code
and shrinking those ginormous models.</p>

<p>To get started let&rsquo;s look at the examples I listed in the last
paragraph. Imagine we have a model file that looks like this:</p>

<pre><code class="ruby">class Account &lt; ActiveRecord::Base
  # Hundreds of lines of CRUFT
  # .
  # .

  def reset_spend_cap
    # stuff
  end

  def set_spend_cap
    # stuff
  end

  # Maybe even hundreds more!!
  # .
  # .
end
</code></pre>

<p>Without even knowing what these two methods do we can see that they
share something in common. They both deal with something called a &ldquo;Spend
Cap.&rdquo; This is a concept in the Facebook Marketing API, but could just as
easily be connected to any environment&rsquo;s domain specific functionality.
Now imagine that Facebook decides to add a whole lot more functionality
to their SpendCap model&hellip;what do we do? (*Hint: if you say &ldquo;write the
methods in the Account model!&rdquo; I&rsquo;m going to find you
and&hellip;ahem&hellip;<a href="http://izquotes.com/quote/299176">explain things</a> to you)</p>

<p>We make a Plain Old Ruby object of course!! Take all those new methods
you&rsquo;ll have to write and move them to their own class like this:</p>

<pre><code class="ruby"># app/models/spend_cap.rb

class SpendCap
  attr_accessor :account

  def initialize(account)
    self.account = account
  end

  def reset
    # stuff, now using the instance variable :account
  end

  def set
    # stuff, now using the instance variable :account
  end
end
</code></pre>

<p>Yup! It&rsquo;s that easy to create POR objects and house them in Rails. Just
put them in the <code>models</code> directory and <em>DON&rsquo;T</em> inherit the class from
<code>ActiveRecord::Base</code>. Plus, now when we want reset a spend cap we can
write the following which is much more readable in terms of the &ldquo;What
the f*^@ is going on here&rdquo; perspective:</p>

<pre><code class="ruby">account = Account.find(params[:id])
SpendCap.new(account).reset
</code></pre>

<p>This is mostly clean code and it gives us a really convenient place to
put business logic and new features related to the SpendCap
functionality. I say &ldquo;mostly clean&rdquo; because I don&rsquo;t really like the look
of <code>SpendCap.new(account).reset</code> and I <em>REALLY</em> hate typing it. The
<code>new</code> method chained in there makes it difficult to read clearly and
we&rsquo;re not really creating something new (except the object in memory,
but in the context of our app, we want to work with code that is
syntactically similar to our business domain). But don&rsquo;t worry, I&rsquo;ve got
a simple trick up my sleeve that has worked great for me.</p>

<h2>A Nifty Initializer</h2>

<p>I mentioned earlier that the constant use of <code>new</code> to pass context
information to a ruby helper object is a little misleading and
cumbersome, plus you end up typing <code>.new(account)</code> six billion times
each day. I&rsquo;ve found that by switching the mental model from &ldquo;A new
SpendCap Model with account&rdquo;, it is helpful to think like an array of
SpendCaps and say &ldquo;The SpendCap for this account&rdquo;. And an implementation
that supports this change looks like this:</p>

<pre><code class="ruby">SpendCap[account].reset
</code></pre>

<p>which in ruby can be easily implemented by adding one extra method to
our SpendCap class:</p>

<pre><code class="ruby"># app/models/spend_cap.rb

class SpendCap
  attr_accessor :account

  def self.[](account)
    self.new(account)
  end

  def initialize(account)
    self.account = account
  end

  def reset
    # stuff, now using the instance variable :account
  end

  def set
    # stuff, now using the instance variable :account
  end
end
</code></pre>

<p>The method signature <code>def self.[](account)</code> creates a class method &ldquo;[]&rdquo;
that accepts a parameter. This way when we&rsquo;re writing against our helper
object, we can think of the object in a more efficient way, we reduce
the overall characters needed, and it just plain looks cleaner to me.</p>

<h2>Conclusion</h2>

<p>Plain old ruby objects are an extremely powerful way to encapsulate
similar functionality and to introduce some domain abstraction into your
application. It also has the added benefit of tying pieces of code to
terms and concepts used in the problem domain so new developers will
learn things like Facebook&rsquo;s SpendCap and immediately have the
information necessary to look directly at the functionality that
supports it.  <em>BONUS</em> They&rsquo;re super easy to use and should be in every
Rails engineer&rsquo;s toolbox.</p>

<p>The new initializer pattern I introduced is a clean way of working with
these objects and makes working with them downright enjoyable. I highly
recommend that the next time you&rsquo;re facing down a monolithic rails
model, take a look at how you may be able to abstract some of the mess
away into helper objects.</p>
]]></content>
  </entry>
  
</feed>
